\chapter{CONCLUSION}
Two contributions were made through this paper. First, a data dependency graph analysis was introduced as a new means of analyzing binaries in the \code{angr} ecosystem. By employing a recursive-descent parser and a simulated register file and dedicated memory, the analysis is able to track dependencies between data regions throughout a program's execution. The subset of instructions analyzed can be altered through fine-grained controls that allow the user to specify a subset of executed instructions for graph generation. This data dependency graph can also be visualized through a custom \code{angr management} data dependency view.

Secondly, the efficacy of this view was tested through a user study that utilized a customized \code{angr} wrapper and a cloud-based deployment framework. In the experiment, users were split into a control and experimental group and were asked to solve a series of software-debugging and more generalized binary analysis challenges. The results showed an overall increase in the number of challenges correctly solved amongst the experimental group, with a statistically significant increase involving the challenge concerning data dependencies. As for time to solve, participants in the experimental group were able to solve the challenges much faster than their peers in the control group. No statistical significance could be attributed to this observation. Users perceived the view to be incredibly functional, but found its comprehensibility challenging. Based off of user feedback, a numerous amount of lessons learned were proposed with possible future work detailed.

The implementation of data dependency graph in its current state, while showing promising results in its niche, is just the beginning of the possible impact this view could have on binary analysis speed and accuracy. Should the suggestions posed in the future work be adopted, the view could see much more impressive results in future user studies. It is hoped that the user study design proposed in this paper should serve as a template for any future studies in this vein in order to continue to enrich the suite of tools available to the software debugger and binary analyst of the future.